# -*- graphql -*-
#
# michael a.g. aïvázis <michael.aivazis@para-sim.com>
# (c) 1998-2021 all rights reserved

schema {
  query: Query
  mutation: Mutation
}


# the top level query
type Query {
  # the active flow
  flow(name: String = ""): Flow!

  # the set of protocols for products and factories in a given package
  catalog(package: String = "flocor"): Catalog

  # basic node from {pyre.calc}
  # variables
  calcVariables: [Specification!]!
  # and operators
  calcOperators: [Producer!]!

  # server version information
  version: Version!

  # fetch a node given its id
  node(id: ID!): Node
}


# mutations
type Mutation {
  # place a new node in the flow
  createNode(nodeinfo: CreateNodeInput!): CreateNode!

  # {calc} nodes
  addCalcVariable(info: NewNodeInput!): NewNodeInfo!
  addCalcOperator(info: NewNodeInput!): NewNodeInfo!

  # move an existing n ode
  moveNode(nodeinfo: MoveNodeInput!): MoveNode!
}

type CreateNode {
  # return the newly created node
  node: Node!
}

input CreateNodeInput {
  # its family name
  family: String!
  # and its location on the diagram
  x: Int!
  y: Int!
}


input NewNodeInput {
  # the flow to which it belongs
  flow: ID!
  # the family name of the node
  family: String!
  # and its location in the diagram
  x: Int!
  y: Int!
}

type NewNodeInfo {
  # the flow that owns the new node
  flow: ID!
  # and the node that was added
  node: Node!
}


type MoveNode {
  # refresh the information of the moving node
  node: Node!
}

input MoveNodeInput {
  # the id of the moving node
  id: ID!
  # and its new location on the diagram
  x: Int!
  y: Int!
}


# the flow
type Flow implements Node {
  # flow identification
  id: ID!
  # the name of the flow
  name: String!
  # and its type
  family: String!

  # the set of macros
  macros(after: String, first: Int, before: String, last: Int): MacroConnection!
  evaluators(after: String, first: Int, before: String, last: Int): EvalConnection!
}


# a macro is a named+typed variable
type Macro implements Node {
  id: ID!
  name: String
  family: String!
  position: Position!
}

# support for macro connections
type MacroConnection {
  edges: [MacroEdge]
  pageInfo: PageInfo!
}

type MacroEdge {
  node: Macro
  cursor: String!
}


# a eval node is produces output given some inputs
type Eval implements Node {
  id: ID!
  name: String
  family: String!
  position: Position!
}

# support for macro connections
type EvalConnection {
  edges: [MacroEdge]
  pageInfo: PageInfo!
}

type EvalEdge {
  node: Eval
  cursor: String!
}


# the full set of known specifications and producers in a given package
type Catalog {
  # the package name
  package: String!
  # known product specifications
  specifications: [Specification!]!
  # known factory descriptions
  producers: [Producer!]!
}

# the protocol implemented by data products
type Specification {
  # specifications have family names
  family: String!
}

# the protocol implemented by factories
type Producer {
  # producers have family names
  family: String!
  # inputs
  inputs: [Slot!]!
  # and outputs
  outputs: [Slot!]!
}

# a slot is a paring of a specification with a label; used in laying out producers
type Slot {
  # the name of the slot
  name: String!
  # and its type
  spec: Specification!
}


# server version
type Version {
  major: Int!
  minor: Int!
  micro: Int!
  revid: String!
}


# interfaces
# the flow node interface
interface Node {
  # the node id
  id: ID!
  # and its position
  position: Position
}


# basic types
type Position {
  # the diagram coordinates of a node
  x: Int!
  y: Int!
}

# boilerplate for connections
type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}


# end of file
